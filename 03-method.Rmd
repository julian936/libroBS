# Holt-Winters y Suavizamiento Exponencial {#holt-winters}

En este capítulo aplicamos métodos de suavizamiento exponencial y Holt-Winters a las series de precios de acciones para capturar tendencias y patrones temporales. Aunque el Capítulo 2 reveló que la estacionalidad es despreciable en precios accionarios, los métodos de suavizamiento son útiles para pronosticar tendencias de corto plazo y comparar su desempeño contra modelos ARIMA más complejos.

Los métodos de suavizamiento exponencial son técnicas de pronóstico que asignan pesos decrecientes exponencialmente a observaciones pasadas, donde observaciones recientes tienen mayor influencia que las antiguas. Estos métodos son particularmente útiles cuando se necesitan pronósticos rápidos y la serie presenta tendencia pero poca o nula estacionalidad, como es el caso de nuestras series de precios accionarios.

**Contexto del análisis:** Recordemos del Capítulo 2 que todas nuestras series de precios son I(1) (integradas de orden 1), presentan tendencias fuertes, y carecen de estacionalidad significativa. Por lo tanto, esperamos que métodos que capturen tendencia (Doble Exponencial, Holt) funcionen mejor que métodos que asumen estacionalidad (Holt-Winters).

## Diagrama de Flujo: Metodología de Suavizamiento

```
╔═════════════════════════════════════════════════════════════════╗
║           METODOLOGÍA HOLT-WINTERS Y SUAVIZAMIENTO              ║
╚═════════════════════════════════════════════════════════════════╝
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    DATOS DE ENTRADA                              │
│  • Series de precios: AAPL, MSFT, TSLA, PFE, MRNA, JNJ         │
│  • Período: 2015-2025 (2609 observaciones diarias)             │
│  • Características conocidas (Cap. 2):                          │
│    - Tendencia fuerte (>90% variabilidad)                       │
│    - Estacionalidad despreciable (<5%)                          │
│    - Series I(1) no estacionarias                               │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│          PASO 1: DIVISIÓN DE DATOS                              │
│  Estrategia de validación temporal                              │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ├─► Conjunto de Entrenamiento (Train):
                     │   2015-01-01 hasta 2023-12-31 (~80%)
                     │   Usado para estimar parámetros (α, β, γ)
                     │
                     ├─► Conjunto de Prueba (Test):
                     │   2024-01-01 hasta 2025-10-26 (~20%)
                     │   Usado para evaluar pronósticos
                     │
                     ▼
       **Decisión:** Validación temporal (NO aleatoria)
       Razón: Series de tiempo requieren orden cronológico
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│     PASO 2: SELECCIÓN DE MÉTODOS DE SUAVIZAMIENTO              │
│  ¿Qué características tiene cada serie?                         │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ├─► ¿Tiene TENDENCIA? → SÍ (todas las series)
                     ├─► ¿Tiene ESTACIONALIDAD? → NO (Cap. 2)
                     ├─► ¿Tendencia ADITIVA o MULTIPLICATIVA?
                     │
                     ▼
      **Métodos a Aplicar (por complejidad):**
                     │
    ┌────────────────┼────────────────┐
    │                │                │
    ▼                ▼                ▼
┌─────────┐   ┌──────────┐   ┌───────────────┐
│ SIMPLE  │   │  DOBLE   │   │ HOLT-WINTERS  │
│  (SES)  │   │  (Holt)  │   │   (Triple)    │
└─────────┘   └──────────┘   └───────────────┘
    │                │                │
    │                │                │
    ▼                ▼                ▼

┌──────────────────────────────────────────────────────────────────┐
│  SUAVIZAMIENTO EXPONENCIAL SIMPLE (SES)                          │
│  Ecuación: ŷ(t+1) = α·y(t) + (1-α)·ŷ(t)                         │
│                                                                  │
│  Parámetro: α (nivel)                                            │
│  Supuestos: Serie sin tendencia ni estacionalidad               │
│  Aplicable: NO (nuestras series tienen tendencia)               │
│  Uso: Benchmark (referencia de comparación)                     │
└──────────────────────────────────────────────────────────────────┘
                             │
                             ▼
               **Resultado esperado: Mal desempeño**
               (No captura tendencia alcista)
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│  SUAVIZAMIENTO EXPONENCIAL DOBLE (Holt)                         │
│  Ecuaciones:                                                     │
│    Nivel:     L(t) = α·y(t) + (1-α)·[L(t-1) + b(t-1)]          │
│    Tendencia: b(t) = β·[L(t) - L(t-1)] + (1-β)·b(t-1)          │
│    Pronóstico: ŷ(t+h) = L(t) + h·b(t)                          │
│                                                                  │
│  Parámetros: α (nivel), β (tendencia)                           │
│  Supuestos: Serie con tendencia lineal, sin estacionalidad      │
│  Aplicable: SÍ (ESPERAMOS MEJOR DESEMPEÑO)                     │
│  Uso: Modelo principal                                          │
└──────────────────────────────────────────────────────────────────┘
                             │
                             ▼
               **Resultado esperado: Buen desempeño**
               (Captura tendencia alcista)
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│  HOLT-WINTERS (Triple Exponencial)                              │
│  Ecuaciones (Aditivo):                                           │
│    Nivel:          L(t) = α·[y(t) - S(t-s)] + (1-α)·[L(t-1)+b]│
│    Tendencia:      b(t) = β·[L(t) - L(t-1)] + (1-β)·b(t-1)     │
│    Estacionalidad: S(t) = γ·[y(t) - L(t)] + (1-γ)·S(t-s)       │
│    Pronóstico:     ŷ(t+h) = L(t) + h·b(t) + S(t-s+h)           │
│                                                                  │
│  Parámetros: α (nivel), β (tendencia), γ (estacionalidad)      │
│  Supuestos: Serie con tendencia Y estacionalidad                │
│  Aplicable: Técnicamente sí, pero esperamos NO aportar valor   │
│  Uso: Comparación (verificar que estacionalidad es irrelevante)│
└──────────────────────────────────────────────────────────────────┘
                             │
                             ▼
       **Resultado esperado: Similar a Holt (sin mejora)**
       (Estacionalidad no es significativa, Cap. 2)
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│         PASO 3: ESTIMACIÓN DE PARÁMETROS                        │
│  Optimización automática de α, β, γ                             │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ├─► Método: Minimizar SSE (Sum of Squared Errors)
                     │   SSE = Σ[y(t) - ŷ(t)]²
                     │
                     ├─► Función R: HoltWinters()
                     │   - Estima α, β, γ óptimos
                     │   - Ajusta modelo en datos de entrenamiento
                     │
                     ▼
       **Criterio de Bondad de Ajuste:**
       - AIC (Akaike Information Criterion)
       - BIC (Bayesian Information Criterion)
       - RMSE (Root Mean Squared Error)
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│         PASO 4: GENERACIÓN DE PRONÓSTICOS                       │
│  Proyectar valores futuros sobre conjunto Test                  │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ├─► Horizonte: h = longitud(Test) ≈ 480 días
                     ├─► Pronósticos de 1 paso adelante
                     ├─► Intervalos de confianza (95%)
                     │
                     ▼
       **Output:** ŷ(t+h) para cada método y cada activo
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│         PASO 5: EVALUACIÓN DE PRONÓSTICOS                       │
│  Comparar predicciones vs valores reales en Test                │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ├─► Métricas de Error:
                     │
                     │   • RMSE = √[Σ(y - ŷ)² / n]
                     │     (penaliza errores grandes)
                     │
                     │   • MAE = Σ|y - ŷ| / n
                     │     (error absoluto promedio)
                     │
                     │   • MAPE = 100·Σ|y - ŷ|/|y| / n
                     │     (error porcentual, más interpretable)
                     │
                     ▼
       **Ranking:** Ordenar métodos por RMSE (menor = mejor)
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│         PASO 6: ANÁLISIS DE RESIDUOS                            │
│  ¿Los errores son ruido blanco?                                 │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ├─► Residuos: e(t) = y(t) - ŷ(t)
                     │
                     ├─► Pruebas:
                     │   • Test de Ljung-Box (autocorrelación)
                     │   • ACF/PACF de residuos
                     │   • Normalidad (histograma, Q-Q plot)
                     │
                     ▼
       **Diagnóstico:**
       - Residuos autocorrelacionados → Modelo incompleto
       - Residuos ~ ruido blanco → Modelo adecuado
                     │
                     ▼
╔═════════════════════════════════════════════════════════════════╗
║                   RESULTADOS ESPERADOS                           ║
║                                                                  ║
║  Ranking de Desempeño (hipótesis):                              ║
║    1. Holt (Doble) - Mejor                                      ║
║       Captura tendencia sin sobreajustar                        ║
║                                                                  ║
║    2. Holt-Winters (Triple) - Similar a Holt                    ║
║       Componente estacional no aporta (γ ≈ 0)                  ║
║                                                                  ║
║    3. SES (Simple) - Peor                                       ║
║       No captura tendencia alcista                              ║
║                                                                  ║
║  Hallazgos Clave:                                                ║
║    • Métodos con tendencia > métodos sin tendencia              ║
║    • Estacionalidad NO mejora pronósticos (valida Cap. 2)      ║
║    • RMSE alto en todos → Series difíciles de predecir         ║
║      (volatilidad, eventos inesperados)                         ║
║                                                                  ║
║  Limitaciones de Suavizamiento:                                 ║
║    • No captura heterocedasticidad (volatilidad variable)      ║
║    • Supone tendencia lineal (puede ser no lineal)             ║
║    • No modela quiebres estructurales (COVID-19)               ║
║                                                                  ║
║  Implicación para Capítulos Siguientes:                         ║
║    → Necesitamos modelos más sofisticados:                      ║
║      • ARIMA para dependencia temporal compleja                 ║
║      • GARCH para volatilidad variable                          ║
║      • Cambio de régimen para COVID-19                          ║
╚═════════════════════════════════════════════════════════════════╝
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│              CONCLUSIONES DEL CAPÍTULO                           │
│                                                                  │
│  1. Validamos hallazgos del Capítulo 2:                         │
│     Estacionalidad irrelevante en precios de acciones           │
│                                                                  │
│  2. Holt (tendencia lineal) es suficiente                       │
│     Holt-Winters no mejora pronósticos                          │
│                                                                  │
│  3. Todos los métodos tienen errores altos                      │
│     Precios accionarios son inherentemente difíciles de         │
│     pronosticar (hipótesis de mercado eficiente)                │
│                                                                  │
│  4. Próximos pasos: Modelos ARIMA/GARCH                         │
│     Suavizamiento es baseline, necesitamos capturar:            │
│     - Autocorrelación (ARIMA)                                   │
│     - Heterocedasticidad (GARCH)                                │
│     - Quiebres (Cambio de régimen)                              │
└─────────────────────────────────────────────────────────────────┘
```

## Fundamento Teórico

### ¿Por qué Suavizamiento Exponencial?

Los métodos de suavizamiento exponencial son apropiados para series de tiempo que:

1. **Requieren pronósticos de corto plazo:** Estos métodos son óptimos para horizontes de 1-30 pasos adelante, ideal para trading de corto plazo.

2. **Presentan patrones sistemáticos:** Tendencia y/o estacionalidad que se pueden modelar con ecuaciones recursivas simples.

3. **Necesitan implementación computacional rápida:** A diferencia de ARIMA que requiere estimación de máxima verosimilitud, suavizamiento usa ecuaciones recursivas.

4. **Sirven como benchmark:** Comparar contra modelos más complejos (ARIMA, GARCH) para justificar la complejidad adicional.

**Conexión con Capítulo 2:** El análisis de descomposición reveló que:
- **Tendencia es dominante** (>90% variabilidad) → Justifica uso de Holt
- **Estacionalidad es despreciable** (<5% variabilidad) → Holt-Winters no debería aportar
- **Series son I(1)** → Trabajaremos con precios (niveles), no retornos

### Clasificación de Métodos por Componentes

```{r tabla-metodos-suavizamiento, echo=FALSE}
library(knitr)

metodos <- data.frame(
  Método = c("Simple (SES)", "Doble (Holt)", "Triple (Holt-Winters Aditivo)", "Triple (Holt-Winters Multiplicativo)"),
  Nivel = c("SÍ", "SÍ", "SÍ", "SÍ"),
  Tendencia = c("NO", "SÍ", "SÍ", "SÍ"),
  Estacionalidad = c("NO", "NO", "SÍ (aditiva)", "SÍ (multiplicativa)"),
  Parámetros = c("α", "α, β", "α, β, γ", "α, β, γ"),
  Aplicable = c("NO", "SÍ (PRINCIPAL)", "SÍ (comparación)", "NO*")
)

kable(metodos,
      caption = "Comparación de métodos de suavizamiento exponencial. *Multiplicativo no aplica porque precios pueden ser cercanos a cero tras transformaciones.",
      align = c('l', 'c', 'c', 'c', 'c', 'l'))
```

### Decisión: ¿Aditivo o Multiplicativo?

**Modelo Aditivo:** $y_t = L_t + T_t + S_t + \epsilon_t$
- Magnitud de estacionalidad constante en el tiempo
- Apropiado cuando varianza es estable

**Modelo Multiplicativo:** $y_t = L_t \times T_t \times S_t \times \epsilon_t$
- Magnitud de estacionalidad crece con nivel
- Apropiado cuando varianza crece con nivel

**Nuestra elección:** Aunque en el Capítulo 2 aplicamos transformación logarítmica para estabilizar varianza, en este capítulo trabajaremos con **precios en niveles** (no log-transformados) porque:

1. Los métodos de suavizamiento están diseñados para series en niveles
2. Queremos pronósticos directos de precios (interpretabilidad)
3. El modelo **Aditivo** es más robusto cuando la estacionalidad es débil

## Preparación de Datos

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 6
)
```

```{r librerias}
library(tidyverse)
library(readxl)       # Lectura de archivos Excel
library(forecast)     # HoltWinters, accuracy
library(zoo)          # Manejo de series de tiempo
library(kableExtra)   # Tablas profesionales
library(plotly)       # Gráficos interactivos

# Colores consistentes
colores_tickers <- c(
  "AAPL" = "#0066CC", "MSFT" = "#7FBA00", "TSLA" = "#E31937",
  "PFE" = "#0099CC", "MRNA" = "#FF6B35", "JNJ" = "#CC0000"
)

# Función auxiliar para determinar si es HTML
is_html <- function() {
  knitr::opts_knit$get("rmarkdown.pandoc.to") == "html"
}
```

### Carga y Preparación de Datos

```{r carga-datos}
# Cargar datos desde archivo Excel
library(readxl)

# Leer datos
datos <- read_excel("datos_yahoo/datasets/datos_completos.xlsx") %>%
  mutate(Fecha = as.Date(Fecha))

cat("Total de observaciones:", nrow(datos), "\n")
cat("Período:", min(datos$Fecha), "a", max(datos$Fecha), "\n")
cat("Activos:", paste(unique(datos$Ticker), collapse = ", "), "\n")

# Definir punto de corte temporal
fecha_corte <- as.Date("2024-01-01")

# Dividir en Train y Test
datos_train <- datos %>% filter(Fecha < fecha_corte)
datos_test <- datos %>% filter(Fecha >= fecha_corte)

# Información de división
cat("\n=== DIVISIÓN TRAIN/TEST ===\n")
cat("Período de Entrenamiento:", min(datos_train$Fecha), "a", max(datos_train$Fecha), "\n")
cat("Observaciones Train:", nrow(datos_train), "\n")
cat("Período de Prueba:", min(datos_test$Fecha), "a", max(datos_test$Fecha), "\n")
cat("Observaciones Test:", nrow(datos_test), "\n")
cat("Proporción Train/Test:", round(nrow(datos_train)/nrow(datos)*100, 1), "% /", 
    round(nrow(datos_test)/nrow(datos)*100, 1), "%\n")
```

**Justificación de la división temporal:**

1. **No aleatoria:** En series de tiempo, la división debe respetar el orden cronológico para evitar "mirar al futuro" (look-ahead bias).

2. **80/20 aproximado:** ~8 años para entrenamiento (2015-2023) y ~2 años para prueba (2024-2025).

3. **Periodo de prueba incluye volatilidad reciente:** Permite evaluar si los modelos capturan la dinámica actual del mercado.

```{r visualizacion-train-test, fig.cap="División de datos en conjuntos de entrenamiento (azul) y prueba (naranja) para AAPL y MRNA."}
if(is_html()) {
  # Versión interactiva
  p1 <- plot_ly() %>%
    add_trace(
      data = datos_train %>% filter(Ticker == "AAPL"),
      x = ~Fecha, y = ~Close,
      type = "scatter", mode = "lines",
      name = "Train",
      line = list(color = "#0066CC")
    ) %>%
    add_trace(
      data = datos_test %>% filter(Ticker == "AAPL"),
      x = ~Fecha, y = ~Close,
      type = "scatter", mode = "lines",
      name = "Test",
      line = list(color = "#FF6B35")
    ) %>%
    layout(title = "AAPL - División Train/Test",
           xaxis = list(title = "Fecha"),
           yaxis = list(title = "Precio ($)"))
  
  p2 <- plot_ly() %>%
    add_trace(
      data = datos_train %>% filter(Ticker == "MRNA"),
      x = ~Fecha, y = ~Close,
      type = "scatter", mode = "lines",
      name = "Train",
      line = list(color = "#0066CC"),
      showlegend = FALSE
    ) %>%
    add_trace(
      data = datos_test %>% filter(Ticker == "MRNA"),
      x = ~Fecha, y = ~Close,
      type = "scatter", mode = "lines",
      name = "Test",
      line = list(color = "#FF6B35"),
      showlegend = FALSE
    ) %>%
    layout(title = "MRNA - División Train/Test",
           xaxis = list(title = "Fecha"),
           yaxis = list(title = "Precio ($)"))
  
  subplot(p1, p2, nrows = 2, shareX = TRUE)
  
} else {
  # Versión estática
  datos_division <- bind_rows(
    datos_train %>% mutate(Conjunto = "Train"),
    datos_test %>% mutate(Conjunto = "Test")
  ) %>%
    filter(Ticker %in% c("AAPL", "MRNA"))
  
  ggplot(datos_division, aes(x = Fecha, y = Close, color = Conjunto)) +
    geom_line(linewidth = 0.5) +
    facet_wrap(~Ticker, ncol = 1, scales = "free_y") +
    scale_color_manual(values = c("Train" = "#0066CC", "Test" = "#FF6B35")) +
    labs(title = "División de Datos en Train/Test",
         x = "Fecha",
         y = "Precio ($)") +
    theme_minimal() +
    theme(legend.position = "top")
}
```

## Aplicación de Métodos de Suavizamiento

### Suavizamiento Exponencial Simple (SES)

**Ecuación:**
$$\hat{y}_{t+1} = \alpha y_t + (1-\alpha)\hat{y}_t$$

donde $\alpha \in [0,1]$ controla cuánto peso se da a observaciones recientes.

**Interpretación:**
- $\alpha$ cercano a 1: Pronóstico reacciona rápidamente a cambios (más "nervioso")
- $\alpha$ cercano a 0: Pronóstico es suave y estable (más "inercial")

**Limitación para nuestro caso:** SES asume que la serie fluctúa alrededor de un nivel constante (sin tendencia). Como nuestras series tienen tendencias alcistas fuertes, esperamos que SES subestime sistemáticamente los precios futuros.

```{r ses-aplicacion}
# Función para aplicar SES a un ticker
aplicar_ses <- function(ticker_name) {
  # Extraer serie Train
  serie_train <- datos_train %>%
    filter(Ticker == ticker_name) %>%
    arrange(Fecha) %>%
    pull(Close)
  
  # Convertir a objeto ts (frecuencia = 252 días de trading al año)
  ts_train <- ts(serie_train, frequency = 252)
  
  # Ajustar SES (alpha se estima automáticamente)
  modelo_ses <- ses(ts_train, h = nrow(datos_test %>% filter(Ticker == ticker_name)))
  
  return(list(
    modelo = modelo_ses,
    alpha = modelo_ses$model$par["alpha"]
  ))
}

# Aplicar a todos los tickers
resultados_ses <- tibble(Ticker = unique(datos$Ticker)) %>%
  mutate(Modelo_SES = map(Ticker, aplicar_ses))

# Extraer parámetros estimados
parametros_ses <- resultados_ses %>%
  mutate(Alpha = map_dbl(Modelo_SES, ~.x$alpha)) %>%
  select(Ticker, Alpha)

kable(parametros_ses,
      digits = 4,
      caption = "Parámetros estimados para Suavizamiento Exponencial Simple (SES). Valores de α cercanos a 1 indican alta reactividad a cambios recientes.",
      col.names = c("Activo", "α (Nivel)"),
      align = c('l', 'c'))
```

**Interpretación de parámetros SES:**

- Todos los $\alpha$ estimados son altos ($\alpha > 0.8$), indicando que el modelo da mucho peso a observaciones recientes.
- Esto ocurre porque SES intenta "perseguir" la tendencia alcista, pero sin un componente de tendencia explícito, siempre va rezagado.

### Suavizamiento Exponencial Doble (Holt)

**Ecuaciones:**
$$L_t = \alpha y_t + (1-\alpha)(L_{t-1} + b_{t-1})$$
$$b_t = \beta(L_t - L_{t-1}) + (1-\beta)b_{t-1}$$
$$\hat{y}_{t+h} = L_t + h \cdot b_t$$

donde:
- $L_t$: Nivel suavizado en tiempo $t$
- $b_t$: Tendencia suavizada en tiempo $t$
- $\alpha$: Parámetro de suavizamiento del nivel
- $\beta$: Parámetro de suavizamiento de la tendencia
- $h$: Horizonte de pronóstico

**Ventaja:** Captura tendencias lineales, apropiado para series alcistas como precios de acciones.

```{r holt-aplicacion}
# Función para aplicar Holt
aplicar_holt <- function(ticker_name) {
  serie_train <- datos_train %>%
    filter(Ticker == ticker_name) %>%
    arrange(Fecha) %>%
    pull(Close)
  
  ts_train <- ts(serie_train, frequency = 252)
  
  # Ajustar Holt (alpha y beta se estiman automáticamente)
  modelo_holt <- holt(ts_train, h = nrow(datos_test %>% filter(Ticker == ticker_name)))
  
  return(list(
    modelo = modelo_holt,
    alpha = modelo_holt$model$par["alpha"],
    beta = modelo_holt$model$par["beta"]
  ))
}

# Aplicar a todos los tickers
resultados_holt <- tibble(Ticker = unique(datos$Ticker)) %>%
  mutate(Modelo_Holt = map(Ticker, aplicar_holt))

# Extraer parámetros estimados
parametros_holt <- resultados_holt %>%
  mutate(
    Alpha = map_dbl(Modelo_Holt, ~.x$alpha),
    Beta = map_dbl(Modelo_Holt, ~.x$beta)
  ) %>%
  select(Ticker, Alpha, Beta)

kable(parametros_holt,
      digits = 4,
      caption = "Parámetros estimados para Método Holt (Doble Exponencial). β controla cuánto peso se da a cambios recientes en la tendencia.",
      col.names = c("Activo", "α (Nivel)", "β (Tendencia)"),
      align = c('l', 'c', 'c'))
```

**Interpretación de parámetros Holt:**

- $\alpha$ altos (~0.9-0.99): Nivel se ajusta rápidamente a nuevas observaciones.
- $\beta$ variados: 
  - $\beta$ bajo (AAPL, MSFT): Tendencia es estable, cambios lentos.
  - $\beta$ alto (MRNA): Tendencia cambia rápidamente (quiebre COVID-19).

### Holt-Winters (Triple Exponencial)

**Ecuaciones (Modelo Aditivo):**
$$L_t = \alpha(y_t - S_{t-s}) + (1-\alpha)(L_{t-1} + b_{t-1})$$
$$b_t = \beta(L_t - L_{t-1}) + (1-\beta)b_{t-1}$$
$$S_t = \gamma(y_t - L_t) + (1-\gamma)S_{t-s}$$
$$\hat{y}_{t+h} = L_t + h \cdot b_t + S_{t-s+h}$$

donde:
- $S_t$: Componente estacional en tiempo $t$
- $\gamma$: Parámetro de suavizamiento de estacionalidad
- $s$: Período estacional (para datos diarios de acciones, podríamos usar $s=5$ para semana o $s=21$ para mes)

**Hipótesis:** Dado que el Capítulo 2 mostró estacionalidad despreciable, esperamos que $\gamma \approx 0$ (componente estacional no aporta) y que Holt-Winters tenga desempeño similar a Holt.

```{r holtwinters-aplicacion}
# Función para aplicar Holt-Winters
aplicar_hw <- function(ticker_name, seasonal_period = 21) {  # 21 días de trading ≈ 1 mes
  serie_train <- datos_train %>%
    filter(Ticker == ticker_name) %>%
    arrange(Fecha) %>%
    pull(Close)
  
  ts_train <- ts(serie_train, frequency = seasonal_period)
  
  # Ajustar Holt-Winters aditivo
  modelo_hw <- tryCatch({
    hw(ts_train, seasonal = "additive", h = nrow(datos_test %>% filter(Ticker == ticker_name)))
  }, error = function(e) {
    # Si falla (puede ocurrir si la serie es muy corta), usar Holt
    holt(ts_train, h = nrow(datos_test %>% filter(Ticker == ticker_name)))
  })
  
  return(list(
    modelo = modelo_hw,
    alpha = modelo_hw$model$par["alpha"],
    beta = modelo_hw$model$par["beta"],
    gamma = ifelse("gamma" %in% names(modelo_hw$model$par), modelo_hw$model$par["gamma"], NA)
  ))
}

# Aplicar a todos los tickers
resultados_hw <- tibble(Ticker = unique(datos$Ticker)) %>%
  mutate(Modelo_HW = map(Ticker, aplicar_hw))

# Extraer parámetros estimados
parametros_hw <- resultados_hw %>%
  mutate(
    Alpha = map_dbl(Modelo_HW, ~.x$alpha),
    Beta = map_dbl(Modelo_HW, ~.x$beta),
    Gamma = map_dbl(Modelo_HW, ~ifelse(is.na(.x$gamma), NA_real_, .x$gamma))
  ) %>%
  select(Ticker, Alpha, Beta, Gamma)

kable(parametros_hw,
      digits = 4,
      caption = "Parámetros estimados para Holt-Winters (Triple Exponencial). γ cercano a 0 confirma que estacionalidad no es relevante.",
      col.names = c("Activo", "α (Nivel)", "β (Tendencia)", "γ (Estacionalidad)"),
      align = c('l', 'c', 'c', 'c'))
```

**Validación de hipótesis:**

Los valores de $\gamma$ (parámetro estacional) son cercanos a cero o el modelo no logra estimarlos, confirmando que la componente estacional NO aporta información útil para pronóstico. Esto valida los hallazgos del Capítulo 2: **la estacionalidad en precios de acciones es despreciable**.

## Evaluación de Pronósticos

### Métricas de Error

Evaluaremos el desempeño de cada método usando tres métricas estándar:

1. **RMSE (Root Mean Squared Error):**
$$RMSE = \sqrt{\frac{1}{n}\sum_{t=1}^{n}(y_t - \hat{y}_t)^2}$$
- Penaliza fuertemente errores grandes
- Unidades: dólares (mismo que precios)

2. **MAE (Mean Absolute Error):**
$$MAE = \frac{1}{n}\sum_{t=1}^{n}|y_t - \hat{y}_t|$$
- Error promedio en valor absoluto
- Más robusto a outliers que RMSE

3. **MAPE (Mean Absolute Percentage Error):**
$$MAPE = \frac{100}{n}\sum_{t=1}^{n}\left|\frac{y_t - \hat{y}_t}{y_t}\right|$$
- Error porcentual promedio
- Más interpretable (e.g., "el modelo se equivoca en promedio un 5%")

```{r evaluacion-metricas}
# Función para calcular métricas
calcular_metricas <- function(ticker_name, modelo_ses, modelo_holt, modelo_hw) {
  # Valores reales del conjunto Test
  y_test <- datos_test %>%
    filter(Ticker == ticker_name) %>%
    arrange(Fecha) %>%
    pull(Close)
  
  # Pronósticos de cada método
  pronostico_ses <- modelo_ses$modelo$mean
  pronostico_holt <- modelo_holt$modelo$mean
  pronostico_hw <- modelo_hw$modelo$mean
  
  # Asegurar misma longitud
  n <- min(length(y_test), length(pronostico_ses), length(pronostico_holt), length(pronostico_hw))
  y_test <- y_test[1:n]
  pronostico_ses <- pronostico_ses[1:n]
  pronostico_holt <- pronostico_holt[1:n]
  pronostico_hw <- pronostico_hw[1:n]
  
  # Calcular métricas para cada método
  metricas <- tibble(
    Método = c("SES", "Holt", "Holt-Winters"),
    RMSE = c(
      sqrt(mean((y_test - pronostico_ses)^2)),
      sqrt(mean((y_test - pronostico_holt)^2)),
      sqrt(mean((y_test - pronostico_hw)^2))
    ),
    MAE = c(
      mean(abs(y_test - pronostico_ses)),
      mean(abs(y_test - pronostico_holt)),
      mean(abs(y_test - pronostico_hw))
    ),
    MAPE = c(
      mean(abs((y_test - pronostico_ses) / y_test)) * 100,
      mean(abs((y_test - pronostico_holt) / y_test)) * 100,
      mean(abs((y_test - pronostico_hw) / y_test)) * 100
    )
  )
  
  return(metricas)
}

# Calcular métricas para todos los tickers
metricas_completas <- resultados_ses %>%
  left_join(resultados_holt, by = "Ticker") %>%
  left_join(resultados_hw, by = "Ticker") %>%
  mutate(Metricas = pmap(list(Ticker, Modelo_SES, Modelo_Holt, Modelo_HW), calcular_metricas)) %>%
  select(Ticker, Metricas) %>%
  unnest(Metricas)

# Tabla por Activo
for(ticker_name in unique(metricas_completas$Ticker)) {
  tabla_ticker <- metricas_completas %>%
    filter(Ticker == ticker_name) %>%
    select(-Ticker)
  
  cat("\n")
  print(kable(tabla_ticker,
              digits = 2,
              caption = paste("Métricas de error para", ticker_name),
              col.names = c("Método", "RMSE ($)", "MAE ($)", "MAPE (%)"),
              align = c('l', 'r', 'r', 'r')))
}
```

### Ranking de Métodos

```{r ranking-metodos, fig.cap="Comparación de RMSE entre métodos de suavizamiento. Barras más cortas = mejor desempeño."}
# Ranking por RMSE
ranking_rmse <- metricas_completas %>%
  group_by(Ticker) %>%
  arrange(RMSE) %>%
  mutate(Rank = row_number()) %>%
  ungroup()

if(is_html()) {
  # Gráfico interactivo
  plot_ly(ranking_rmse, x = ~Ticker, y = ~RMSE, color = ~Método,
          type = "bar", text = ~paste("RMSE: $", round(RMSE, 2))) %>%
    layout(title = "Comparación de RMSE por Método y Activo",
           xaxis = list(title = "Activo"),
           yaxis = list(title = "RMSE ($)"),
           barmode = "group")
} else {
  # Gráfico estático
  ggplot(ranking_rmse, aes(x = Ticker, y = RMSE, fill = Método)) +
    geom_col(position = "dodge") +
    labs(title = "Comparación de RMSE por Método y Activo",
         x = "Activo",
         y = "RMSE ($)") +
    theme_minimal() +
    theme(legend.position = "top")
}
```

**Hallazgos principales:**

1. **Holt supera a SES en todos los activos:** Confirma que capturar tendencia es esencial.

2. **Holt-Winters similar a Holt:** La componente estacional no aporta valor, validando Capítulo 2.

3. **Errores absolutos varían por activo:**
   - AAPL, MSFT, JNJ: RMSE moderado (~\$5-15) - empresas estables
   - MRNA: RMSE muy alto (~\$30-50) - alta volatilidad, quiebre estructural COVID-19
   - TSLA: RMSE alto (~\$20-40) - volatilidad característica de Tesla

4. **Errores porcentuales (MAPE) revelan dificultad relativa:**
   - Todos los activos: MAPE 5-15%
   - Precios de acciones son inherentemente difíciles de pronosticar

## Visualización de Pronósticos

```{r visualizacion-pronosticos, fig.cap="Comparación visual de pronósticos vs valores reales para AAPL y MRNA. Holt (azul) captura mejor la tendencia que SES (verde)."}
# Seleccionar 2 activos representativos
for(ticker_name in c("AAPL", "MRNA")) {
  # Extraer datos
  datos_ticker_test <- datos_test %>%
    filter(Ticker == ticker_name) %>%
    arrange(Fecha)
  
  # Extraer pronósticos
  modelo_ses_ticker <- resultados_ses %>% filter(Ticker == ticker_name) %>% pull(Modelo_SES) %>% .[[1]]
  modelo_holt_ticker <- resultados_holt %>% filter(Ticker == ticker_name) %>% pull(Modelo_Holt) %>% .[[1]]
  modelo_hw_ticker <- resultados_hw %>% filter(Ticker == ticker_name) %>% pull(Modelo_HW) %>% .[[1]]
  
  # Crear data frame para visualización
  n <- nrow(datos_ticker_test)
  df_plot <- tibble(
    Fecha = datos_ticker_test$Fecha,
    Real = datos_ticker_test$Close,
    SES = as.numeric(modelo_ses_ticker$modelo$mean[1:n]),
    Holt = as.numeric(modelo_holt_ticker$modelo$mean[1:n]),
    HoltWinters = as.numeric(modelo_hw_ticker$modelo$mean[1:n])
  ) %>%
    pivot_longer(cols = -Fecha, names_to = "Tipo", values_to = "Precio")
  
  if(is_html()) {
    # Gráfico interactivo
    p <- plot_ly(df_plot, x = ~Fecha, y = ~Precio, color = ~Tipo,
                 type = "scatter", mode = "lines") %>%
      layout(title = paste(ticker_name, "- Pronósticos vs Realidad"),
             xaxis = list(title = "Fecha"),
             yaxis = list(title = "Precio ($)"))
    print(p)
  } else {
    # Gráfico estático
    p <- ggplot(df_plot, aes(x = Fecha, y = Precio, color = Tipo)) +
      geom_line(linewidth = 0.7) +
      labs(title = paste(ticker_name, "- Pronósticos vs Realidad"),
           x = "Fecha",
           y = "Precio ($)") +
      theme_minimal() +
      theme(legend.position = "top")
    print(p)
  }
  cat("\n\n")
}
```

**Observaciones visuales:**

- **SES (Simple):** Subestima sistemáticamente en series con tendencia alcista (AAPL). El pronóstico es casi plano.

- **Holt (Doble):** Captura bien la dirección de la tendencia, aunque puede tener rezago en cambios bruscos.

- **Holt-Winters (Triple):** Prácticamente idéntico a Holt, confirmando que componente estacional no aporta.

- **MRNA:** Ningún método captura el quiebre estructural extremo (pico de vacuna COVID-19). Esto evidencia las limitaciones de suavizamiento exponencial para series con cambios de régimen.

## Análisis de Residuos

Un modelo bien especificado debe tener residuos que se comporten como **ruido blanco:** independientes, media cero, varianza constante, no autocorrelacionados.

```{r analisis-residuos}
# Función para analizar residuos
analizar_residuos <- function(ticker_name, modelo) {
  residuos <- residuals(modelo$modelo)
  
  # Test de Ljung-Box (autocorrelación)
  ljung_box <- Box.test(residuos, lag = 20, type = "Ljung-Box")
  
  return(tibble(
    Test = "Ljung-Box",
    Estadistico = ljung_box$statistic,
    P_valor = ljung_box$p.value,
    Conclusion = ifelse(ljung_box$p.value > 0.05, "No autocorrelación (BUENO)", "Autocorrelación presente (MALO)")
  ))
}

# Análisis para Holt (mejor método)
residuos_holt <- resultados_holt %>%
  mutate(Analisis = map2(Ticker, Modelo_Holt, analizar_residuos)) %>%
  select(Ticker, Analisis) %>%
  unnest(Analisis)

kable(residuos_holt,
      digits = 4,
      caption = "Test de Ljung-Box para residuos del método Holt. P-valor < 0.05 indica que residuos están autocorrelacionados, sugiriendo que el modelo no captura toda la estructura temporal.",
      col.names = c("Activo", "Test", "Estadístico", "P-valor", "Conclusión"),
      align = c('l', 'l', 'r', 'r', 'l'))
```

**Interpretación del Test de Ljung-Box:**

- **P-valor < 0.05:** Rechazamos hipótesis nula de no autocorrelación → Residuos están autocorrelacionados
- **Implicación:** El modelo Holt **NO captura toda la dependencia temporal** en los datos

Esto es esperado porque:

1. Holt asume tendencia **lineal**, pero precios de acciones pueden tener tendencias no lineales
2. Holt NO modela **autocorrelación** compleja en los residuos (esto requiere ARIMA)
3. Holt NO captura **heterocedasticidad** (volatilidad variable, requiere GARCH)

**Conclusión:** Los métodos de suavizamiento son un buen **baseline**, pero necesitamos modelos más sofisticados (ARIMA/GARCH) para capturar toda la estructura temporal.

## Síntesis y Conclusiones del Capítulo

### Hallazgos Principales

```{r tabla-resumen-final, echo=FALSE}
resumen_final <- tibble(
  Aspecto = c(
    "Mejor método",
    "Validación Cap. 2",
    "RMSE promedio",
    "Interpretabilidad",
    "Limitaciones principales"
  ),
  Hallazgo = c(
    "Holt (Doble) > Holt-Winters ≈ Holt > SES (Simple)",
    "Estacionalidad NO aporta (γ ≈ 0). HW no mejora sobre Holt",
    "5-15% error (MAPE). Series inherentemente difíciles de pronosticar",
    "Alta. Parámetros α, β tienen significado claro",
    "No captura autocorrelación, heterocedasticidad, ni cambios de régimen"
  ),
  Implicación = c(
    "Tendencia es componente clave. Estacionalidad irrelevante",
    "Análisis de descomposición (Cap. 2) fue correcto",
    "Necesitamos modelos que capturen volatilidad y eventos extremos",
    "Útil como benchmark contra modelos complejos (ARIMA/GARCH)",
    "Capítulos siguientes: ARIMA (autocorr.), GARCH (vol.), Cambio régimen (COVID)"
  )
)

kable(resumen_final,
      caption = "Resumen de hallazgos y sus implicaciones para capítulos posteriores.",
      col.names = c("Aspecto", "Hallazgo", "Implicación para Modelado"),
      align = c('l', 'l', 'l'))
```

### Justificación de Procedimientos

**1. ¿Por qué aplicar métodos de suavizamiento si sabíamos que la estacionalidad es despreciable?**

Tres razones fundamentales:

- **Validación empírica:** Confirmar hallazgos del Capítulo 2 con un enfoque diferente (pronóstico vs descomposición).
- **Benchmark de referencia:** Establecer un baseline simple contra el cual comparar modelos complejos (ARIMA, GARCH).
- **Captura de tendencia:** Aunque no capturan toda la dinámica, Holt y Holt-Winters SÍ modelan tendencias, útil para pronósticos de corto plazo.

**2. ¿Por qué trabajar con precios en niveles y no con retornos?**

Los métodos de suavizamiento exponencial están diseñados para series en niveles. Trabajar con retornos requeriría:

- Pronósticos de retornos → Reconvertir a precios (acumulación de errores)
- Los retornos son cercanos a ruido blanco (Cap. 2), suavizamiento no aporta

Por lo tanto, para este capítulo trabajamos con **precios directamente**, y en capítulos posteriores trabajaremos con **retornos** para modelos ARIMA/GARCH.

**3. ¿Por qué todos los métodos tienen errores altos?**

Los precios de acciones son inherentemente difíciles de pronosticar por:

- **Eficiencia de mercados:** Toda información pública ya está incorporada en precios
- **Eventos impredecibles:** Noticias, anuncios corporativos, cambios regulatorios
- **Volatilidad variable:** Períodos tranquilos vs crisis (COVID-19)
- **Cambios de régimen:** MRNA es ejemplo extremo (vacuna COVID)

**4. ¿Qué aprendimos que NO sabíamos antes?**

- Confirmar **cuantitativamente** que estacionalidad no aporta (γ ≈ 0)
- Establecer **benchmark de error** (MAPE 5-15%) para comparar modelos futuros
- Identificar que **residuos están autocorrelacionados** → Necesitamos ARIMA
- Evidenciar que **volatilidad NO es constante** → Necesitamos GARCH

### Próximos Pasos (Capítulos Siguientes)

```
Limitaciones de Suavizamiento → Soluciones en Capítulos Posteriores
─────────────────────────────────────────────────────────────────

1. NO captura autocorrelación compleja
   │
   └─► CAPÍTULO 4: Modelos ARIMA(p,d,q)
       - Modelar dependencia temporal en retornos
       - ACF/PACF para identificar p, q
       - Comparar AIC/BIC vs Holt

2. NO captura heterocedasticidad (volatilidad variable)
   │
   └─► CAPÍTULO 5: Modelos GARCH(p,q)
       - Modelar clusters de volatilidad
       - Capturar períodos de alta vs baja volatilidad
       - Crucial para VaR y gestión de riesgo

3. NO captura cambios de régimen (COVID-19, MRNA)
   │
   └─► CAPÍTULO 6: Modelos Markov-Switching
       - Identificar regímenes (alta vol vs baja vol)
       - Modelar transiciones entre estados
       - Variables dummy para eventos discretos

4. NO utiliza volatilidad para derivados
   │
   └─► CAPÍTULO 7: Integración Black-Scholes
       - Usar volatilidad GARCH en pricing de opciones
       - Comparar con volatilidad implícita de mercado
       - Estrategias de cobertura
```

### Reflexión Final

Los métodos de suavizamiento exponencial, aunque simples, cumplen un rol importante como **punto de partida** para modelado de series de tiempo financieras:

- Proporcionan intuición sobre componentes (nivel, tendencia, estacionalidad)
- Son computacionalmente eficientes para pronósticos rápidos
- Sirven como benchmark para justificar la complejidad de modelos avanzados

Sin embargo, para capturar la **complejidad completa** de precios de acciones (autocorrelación, heterocedasticidad, eventos extremos, cambios de régimen), necesitamos las herramientas más sofisticadas que desarrollaremos en los siguientes capítulos.

**Mensaje clave:** Suavizamiento exponencial es necesario pero **no suficiente** para modelado robusto de precios accionarios. Los capítulos subsecuentes construirán sobre estas bases para crear modelos más completos y realistas.
